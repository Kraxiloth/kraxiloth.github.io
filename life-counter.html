
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCG Life Counter</title>
    <style>
        body {
            background-color: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
		
		.modal-overlay {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.85);
			z-index: 100;
			align-items: center;
			justify-content: center;
			flex-direction: column;
			gap: 15px;
		}

		.modal-overlay.active {
			display: flex;
		}

		.modal-content {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 15px;
			max-height: 90vh;
			overflow-y: auto;
			width: 90vw;
			max-width: 400px;
			background-color: #1e1e1e;
			border-radius: 12px;
			padding: 20px;
			box-sizing: border-box;
		}

		.modal-image {
			max-width: 80vw;
			max-height: 70vh;
			aspect-ratio: 5 / 7;
			border-radius: 12px;
			object-fit: cover;
		}

		.modal-close {
			position: fixed;
			top: 20px;
			right: 20px;
			background-color: #333333;
			color: #ffffff;
			border: none;
			border-radius: 50%;
			width: 40px;
			height: 40px;
			font-size: 18px;
			cursor: pointer;
		}

		.modal-change {
			background-color: #444444;
			color: #ffffff;
			border: none;
			padding: 12px 24px;
			border-radius: 8px;
			font-size: 16px;
			cursor: pointer;
			align-self: center;
		}

		.modal-change:hover {
			background-color: #666666;
		}
		
		.browser-title {
			margin: 0;
			font-size: 18px;
			color: #ffffff;
			text-align: center;
		}
		
		.browser-controls {
			display: flex;
			flex-direction: column;
			gap: 8px;
			width: 100%;
		}
		
		#avatar-search {
			width: 100%;
			padding: 10px;
			background-color: #2a2a2a;
			border: 1px solid #444444;
			border-radius: 8px;
			color: #ffffff;
			font-size: 16px;
			box-sizing: border-box;
		}
		
		#avatar-search::placeholder {
			color: #666666;
		}
		
		.finish-toggle {
			display: flex;
			align-items: center;
			gap: 8px;
			font-size: 14px;
			color: #aaaaaa;
			cursor: pointer;
		}
		
		.avatar-list {
			width: 100%;
			display: flex;
			flex-direction: column;
			gap: 6px;
			max-height: 40vh;
			overflow-y: auto;
		}
		
		.avatar-list-item {
			background-color: #2a2a2a;
			border: 1px solid #444444;
			border-radius: 8px;
			padding: 10px 14px;
			cursor: pointer;
			font-size: 15px;
			color: #ffffff;
			text-align: left;
		}
		
		.avatar-list-item:hover {
			background-color: #3a3a3a;
			border-color: #666666;
		}
		
		.avatar-preview {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 12px;
			width: 100%;
		}
		
		.avatar-preview img {
			max-width: 60vw;
			max-height: 50vh;
			aspect-ratio: 5 / 7;
			border-radius: 10px;
			object-fit: cover;
		}
		
		.modal-cancel {
			background-color: #333333;
			color: #aaaaaa;
			border: none;
			padding: 10px 20px;
			border-radius: 8px;
			font-size: 15px;
			cursor: pointer;
		}
		
		.browser-loading {
			color: #666666;
			text-align: center;
			padding: 20px;
		}
		
		.container {
			display: flex;
			flex-wrap: wrap;
			justify-content: center;
			width: 100%;
			max-width: 800px;
			gap: 20px;
		}
		
		.player {
			background-color: #1e1e1e;
			padding: 20px;
			border-radius: 10px;
			flex: 1 1 300px;
			max-width: 360px;
			display: grid;
			grid-template-columns: 1fr 45%;
			grid-template-rows: auto 1fr;
			column-gap: 10px;
			row-gap: 10px;
			align-items: stretch;
		}
		
		.player-top {
			display: flex;
			flex-direction: row;
			gap: 10px;
			margin-bottom: 10px;
			align-items: flex-end;
		}
		
		.player-left {
			flex: 1;
			min-width: 0;
			display: flex;
			flex-direction: column;
		}
		
		.player-avatar {
			grid-column: 2;
			grid-row: 1 / 3;
		}
		
		.player-life {
			grid-column: 1;
			grid-row: 2;
			display: flex;
			flex-direction: column;
			justify-content: flex-end;
		}
		
		.player-life .section {
			margin: 0;
		}
		
		.player-mana {
			grid-column: 1 / 3;
		}
		
		.player-threshold {
			grid-column: 1 / 3;
		}
		
		.player-right {
			width: 45%;
			flex-shrink: 0;
		}

		.avatar-card {
			width: 100%;
			aspect-ratio: 5 / 7;
			background-color: #2a2a2a;
			border-radius: 8px;
			display: flex;
			align-items: center;
			justify-content: center;
			overflow: hidden;
			border: 1px solid #444444;
			position: relative;
		}

		.avatar-initial {
			font-size: 48px;
			color: #666666;
			font-weight: bold;
			position: absolute;
			z-index: 0;
		}

		.avatar-card img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			position: absolute;
			z-index: 1;
		}
		
		.player-header {
			margin-bottom: 0;
			padding: 0;
		}
		
		.player-initial {
		}
		
		.player-name {
			grid-column: 1;
			grid-row: 1;
			margin: 0;
			font-size: 20px;
			cursor: pointer;
			align-self: center;
		}
		
		.button-row {
		}
		
		.section {
			margin: 15px 0;
			padding: 10px;
			background-color: #2a2a2a;
			border-radius: 8px;
		}

		.section h3 {
			margin: 0 0 8px;
			font-size: 16px;
			color: #aaaaaa;
			text-transform: uppercase;
			letter-spacing: 1px;
		}

		.subsection {
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin: 6px 0;
		}

		.subsection span {
			font-size: 14px;
			color: #cccccc;
			width: 60px;
			text-align: left;
		}

		.value {
			font-size: 48px;
			margin: 10px 0;
			min-height: 60px;
			line-height: 60px;
			overflow: hidden;
		}

		.value.small {
			font-size: 18px;
			min-height: unset;
			margin: 0;
			width: 30px;
			text-align: center;
			line-height: normal;
		}

		.global-buttons {
			display: flex;
			flex-wrap: wrap;
			gap: 10px;
			margin-top: 20px;
			justify-content: center;
			padding: 0 10px;
		}

		@media (max-width: 600px) {
			.section h3 {
				font-size: 14px;
			}

			.subsection span {
				font-size: 12px;
			}

			.value.small {
				font-size: 16px;
			}
		}
    </style>
</head>
<body>
	<div class="container" id="container"></div>
	<div class="global-buttons">
		<select id="player-count" onchange="handlePlayerCount()">
			<option value="1">1 Player</option>
			<option value="2">2 Players</option>
			<option value="3">3 Players</option>
			<option value="4">4 Players</option>
			<option value="5">5 Players</option>
			<option value="6">6 Players</option>
		</select>
		<button onclick="newTurn()">New Turn</button>
		<button onclick="resetGame()">Reset</button>
		<select id="remove-player" onchange="handleRemovePlayer()">
			<option value="">Remove Player</option>
		</select>
	</div>
	
	<div class="modal-overlay" id="modal-overlay" onclick="closeModal()">
		<div class="modal-content" onclick="event.stopPropagation()">
			<button class="modal-close" onclick="closeModal()">âœ•</button>
			
			<div id="modal-view-card">
				<img class="modal-image" id="modal-image" src="" alt="Avatar">
				<button class="modal-change" onclick="openAvatarBrowser()">Change Avatar</button>
			</div>

			<div id="modal-avatar-browser" style="display:none" onclick="event.stopPropagation()>
				<h3 class="browser-title">Select Avatar</h3>
				<div class="browser-controls">
					<input type="text" id="avatar-search" placeholder="Search avatars..." oninput="handleSearchInput() onclick="event.stopPropagation()">
					<label class="finish-toggle">
						<input type="checkbox" id="show-all-finishes" onchange="filterAvatars()">
						Show all finishes
					</label>
				</div>
				<div id="avatar-list" class="avatar-list">
					<div class="browser-loading">Loading avatars...</div>
				</div>
				<div id="avatar-preview" class="avatar-preview" style="display:none">
					<img id="preview-image" src="" alt="Preview">
					<button class="modal-change" onclick="confirmAvatar()">Select This Avatar</button>
					<button class="modal-cancel" onclick="clearPreview()">Back</button>
				</div>
			</div>
		</div>
	</div>
	
    <script>

	function createPlayerPanel(index, player) {
		const avatarSrc = player.avatar 
			? `${IMAGE_BASE_URL}${player.avatar}.png`
			: 'bet-sorcerer-b-s.webp';
		const num = index + 1;
		const rotation = index === 1 ? 'style="transform: rotate(180deg)"' : '';
		return `
			<div class="player" id="player-${num}" ${rotation}>
				<h2 class="player-name" id="name${num}" onclick="renamePlayer(${index})">${player.name}</h2>
				<div class="player-avatar">
					<div class="avatar-card" id="avatar${num}" onclick="openModal(${index})">
						<img src="${avatarSrc}" alt="Avatar" onerror="this.style.display='none'">
						<div class="avatar-initial" id="avatar-initial${num}">${player.name.charAt(0).toUpperCase()}</div>
					</div>
				</div>
				<div class="player-life">
					<div class="section">
						<h3>Life</h3>
						<div class="value" id="life${num}">${player.life}</div>
						<div class="button-row">
							<button onclick="adjustLife(${index}, -1)">-</button>
							<button onclick="adjustLife(${index}, 1)">+</button>
						</div>
					</div>
				</div>
				<div class="player-mana section">
					<h3>Mana</h3>
					<div class="value" id="mana${num}">${player.mana} / ${player.maxMana}</div>
					<div class="subsection">
						<span>Current</span>
						<button onclick="adjustMana(${index}, 'current', -1)">-</button>
						<button onclick="adjustMana(${index}, 'current', 1)">+</button>
					</div>
					<div class="subsection">
						<span>Maximum</span>
						<button onclick="adjustMana(${index}, 'max', -1)">-</button>
						<button onclick="adjustMana(${index}, 'max', 1)">+</button>
					</div>
				</div>
				<div class="player-threshold section">
					<h3>Threshold</h3>
					<div class="subsection">
						<span>Air</span>
						<button onclick="adjustThreshold(${index}, 'air', -1)">-</button>
						<div class="value small" id="threshold-air${num}">${player.threshold.air}</div>
						<button onclick="adjustThreshold(${index}, 'air', 1)">+</button>
					</div>
					<div class="subsection">
						<span>Fire</span>
						<button onclick="adjustThreshold(${index}, 'fire', -1)">-</button>
						<div class="value small" id="threshold-fire${num}">${player.threshold.fire}</div>
						<button onclick="adjustThreshold(${index}, 'fire', 1)">+</button>
					</div>
					<div class="subsection">
						<span>Earth</span>
						<button onclick="adjustThreshold(${index}, 'earth', -1)">-</button>
						<div class="value small" id="threshold-earth${num}">${player.threshold.earth}</div>
						<button onclick="adjustThreshold(${index}, 'earth', 1)">+</button>
					</div>
					<div class="subsection">
						<span>Water</span>
						<button onclick="adjustThreshold(${index}, 'water', -1)">-</button>
						<div class="value small" id="threshold-water${num}">${player.threshold.water}</div>
						<button onclick="adjustThreshold(${index}, 'water', 1)">+</button>
					</div>
				</div>
			</div>
		`;
	}

	// Player factory function
	function createPlayer(name) {
		return {
			name: name,
			life: 20,
			mana: 0,
			maxMana: 0,
			threshold: { air: 0, fire: 0, earth: 0, water: 0 }
		};
	}

	// Start with a single default player
	let players = [createPlayer("Player 1")];
	
	// Add more players
	function addPlayer() {
		const name = prompt('Enter player name:', `Player ${players.length + 1}`);
		if (name && name.trim() !== '') {
			player.push(createPlayer(name.trim()));
			renderPlayers();
		}
	}
	
	function renderPlayers() {
		const container = document.getElementById('container');
		container.innerHTML = '';
		players.forEach((player, index) => {
			container.innerHTML += createPlayerPanel(index, player);
		});
	}
	
	function handlePlayerCount() {
		const select = document.getElementById('player-count');
		const newCount = parseInt(select.value);
		const currentCount = players.length;

		if (newCount > currentCount) {
			// Add players up to the new count
			for (let i = currentCount; i < newCount; i++) {
				const name = prompt('Enter player name:', `Player ${i + 1}`);
				if (name && name.trim() !== '') {
					players.push(createPlayer(name.trim()));
				} else {
					// If cancelled, reset dropdown to current count
					select.value = players.length;
					return;
				}
			}
		} else if (newCount < currentCount) {
			// Confirm before removing players
			const removing = currentCount - newCount;
			const plural = removing > 1 ? 'players' : 'player';
			if (confirm(`This will remove ${removing} ${plural}. Are you sure?`)) {
				players = players.slice(0, newCount);
			} else {
				// If cancelled, reset dropdown to current count
				select.value = players.length;
				return;
			}
		}

		renderPlayers();
		updateRemoveDropdown();
	}

	function updateRemoveDropdown() {
		const select = document.getElementById('remove-player');
		select.innerHTML = '<option value="">Remove Player</option>';
		players.forEach((player, index) => {
			select.innerHTML += `<option value="${index}">${player.name}</option>`;
		});
	}

	function handleRemovePlayer() {
		const select = document.getElementById('remove-player');
		const index = parseInt(select.value);
		if (isNaN(index)) return;
		
		if (confirm(`Remove ${players[index].name} from the game?`)) {
			players.splice(index, 1);
			renderPlayers();
			updateRemoveDropdown();
			// Sync player count dropdown
			document.getElementById('player-count').value = players.length;
		} else {
			select.value = '';
		}
	}
	// Update the display for a single player
	function updateDisplay(playerIndex) {
		const player = players[playerIndex];
		const num = playerIndex + 1;
		document.getElementById(`name${num}`).textContent = player.name;
		document.getElementById(`life${num}`).textContent = player.life < 1 ? 'ðŸ’”' : player.life;
		document.getElementById(`mana${num}`).textContent = `${player.mana} / ${player.maxMana}`;
		document.getElementById(`threshold-air${num}`).textContent = player.threshold.air;
		document.getElementById(`threshold-fire${num}`).textContent = player.threshold.fire;
		document.getElementById(`threshold-earth${num}`).textContent = player.threshold.earth;
		document.getElementById(`threshold-water${num}`).textContent = player.threshold.water;
	}

	// Life adjustment
	function adjustLife(playerIndex, amount) {
		players[playerIndex].life = Math.max(0, Math.min(20, players[playerIndex].life + amount));
		updateDisplay(playerIndex);
	}

	// Mana adjustment â€” current and maximum stay in sync
	function adjustMana(playerIndex, type, amount) {
		const player = players[playerIndex];
		if (type === 'max') {
			player.maxMana = Math.max(0, player.maxMana + amount);
			// Sync current mana with the new maximum
			player.mana = Math.min(player.mana + amount, player.maxMana);
			player.mana = Math.max(0, player.mana);
		} else {
			player.mana = Math.max(0, Math.min(player.maxMana, player.mana + amount));
		}
		updateDisplay(playerIndex);
	}

	// Threshold adjustment
	function adjustThreshold(playerIndex, element, amount) {
		players[playerIndex].threshold[element] = Math.max(0, players[playerIndex].threshold[element] + amount);
		updateDisplay(playerIndex);
	}

	// Rename a player directly on the panel
	function renamePlayer(playerIndex) {
		const current = players[playerIndex].name;
		const newName = prompt("Enter new name:", current);
		if (newName && newName.trim() !== '') {
			players[playerIndex].name = newName.trim();
			updateDisplay(playerIndex);
		}
	}

	// New turn â€” reset current mana to maximum for all players
	function newTurn() {
		players.forEach((player, index) => {
			player.mana = player.maxMana;
			updateDisplay(index);
		});
	}

	// Reset all players to default state
	function resetGame() {
		if (confirm("Reset all players to default state?")) {
			players = players.map(player => createPlayer(player.name));
			players.forEach((_, index) => updateDisplay(index));
		}
	}
	
	// Modal shenaningans
	function openModal(playerIndex) {
		currentAvatarPlayerIndex = playerIndex;
		const avatarCard = document.getElementById(`avatar${playerIndex + 1}`);
		const img = avatarCard.querySelector('img');
		const modalImage = document.getElementById('modal-image');
		if (img && img.style.display !== 'none') {
			modalImage.src = img.src;
		} else {
			modalImage.src = '';
		}
		document.getElementById('modal-overlay').classList.add('active');
		document.getElementById('modal-view-card').style.display = 'flex';
		document.getElementById('modal-view-card').style.flexDirection = 'column';
		document.getElementById('modal-view-card').style.alignItems = 'center';
		document.getElementById('modal-avatar-browser').style.display = 'none';
	}

	function closeModal() {
		document.getElementById('modal-overlay').classList.remove('active');
	}
	
	// Avatar browser state
	const IMAGE_BASE_URL = 'https://d27a44hjr9gen3.cloudfront.net/cards/';
	const API_URL = 'https://api.sorcerytcg.com/api/cards';
	const CACHE_KEY = 'avatarCache';
	const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

	let avatarList = [];
	let filteredAvatars = [];
	let currentAvatarPlayerIndex = null;
	let selectedAvatarSlug = null;

	// Open avatar browser for a specific player
	function openAvatarBrowser(playerIndex) {
		if (playerIndex !== undefined) {
			currentAvatarPlayerIndex = playerIndex;
		}
		document.getElementById('modal-view-card').style.display = 'none';
		document.getElementById('modal-avatar-browser').style.display = 'flex';
		document.getElementById('modal-avatar-browser').style.flexDirection = 'column';
		clearPreview();
		
		if (avatarList.length > 0) {
			renderAvatarList(avatarList);
		} else {
			loadAvatars();
		}
	}

	// Load avatars from cache or API
	async function loadAvatars() {
		document.getElementById('avatar-list').innerHTML = '<div class="browser-loading">Loading avatars...</div>';
		
		// Check cache first
		try {
			const cached = localStorage.getItem(CACHE_KEY);
			if (cached) {
				const { data, timestamp } = JSON.parse(cached);
				if (Date.now() - timestamp < CACHE_DURATION) {
					avatarList = data;
					renderAvatarList(avatarList);
					return;
				}
			}
		} catch (error) {
			console.log('Cache read failed, fetching fresh data');
		}

		// Fetch from local JSON file
		try {
			const response = await fetch('avatars.json');
			avatarList = await response.json();

			// Cache the results
			try {
				localStorage.setItem(CACHE_KEY, JSON.stringify({
					data: avatarList,
					timestamp: Date.now()
				}));
			} catch (error) {
				console.log('Cache write failed');
			}

			renderAvatarList(avatarList);
		} catch (error) {
			document.getElementById('avatar-list').innerHTML = 
				'<div class="browser-loading">Failed to load avatar list.</div>';
		}
	}

	// Render the avatar list based on current filters
	function renderAvatarList(avatars) {
		const searchTerm = document.getElementById('avatar-search').value.toLowerCase();
		const showAllFinishes = document.getElementById('show-all-finishes').checked;
		
		filteredAvatars = avatars.filter(avatar => {
			const matchesSearch = avatar.name.toLowerCase().includes(searchTerm) ||
								avatar.set.toLowerCase().includes(searchTerm);
			const matchesFinish = showAllFinishes || avatar.finish === 'Standard';
			return matchesSearch && matchesFinish;
		});

		if (filteredAvatars.length === 0) {
			document.getElementById('avatar-list').innerHTML = 
				'<div class="browser-loading">No avatars found.</div>';
			return;
		}

		document.getElementById('avatar-list').innerHTML = filteredAvatars
			.map((avatar, index) => `
				<button class="avatar-list-item" onclick="previewAvatar(${index})">
					${avatar.name} - ${avatar.set}
					${avatar.finish !== 'Standard' ? `<span style="color:#aaaaaa"> (${avatar.finish})</span>` : ''}
				</button>
			`)
			.join('');
	}

	// Filter avatars based on search input
	
	function filterAvatars() {
		renderAvatarList(avatarList);
	}

	function handleSearchInput() {
		clearPreview();
		filterAvatars();
	}

	// Preview a selected avatar
	function previewAvatar(filteredIndex) {
		const avatar = filteredAvatars[filteredIndex];
		selectedAvatarSlug = avatar.slug;
		
		const previewImg = document.getElementById('preview-image');
		previewImg.src = `${IMAGE_BASE_URL}${avatar.slug}.png`;
		
		document.getElementById('avatar-list').style.display = 'none';
		document.getElementById('avatar-preview').style.display = 'flex';
	}

	// Clear preview and go back to list
	function clearPreview() {
		selectedAvatarSlug = null;
		document.getElementById('avatar-preview').style.display = 'none';
		document.getElementById('avatar-list').style.display = 'flex';
		document.getElementById('avatar-list').style.flexDirection = 'column';
		document.getElementById('avatar-search').value = '';
		renderAvatarList(avatarList);
	}

	// Confirm avatar selection
	function confirmAvatar() {
		if (selectedAvatarSlug === null || currentAvatarPlayerIndex === null) return;
		
		players[currentAvatarPlayerIndex].avatar = selectedAvatarSlug;
		
		const avatarCard = document.getElementById(`avatar${currentAvatarPlayerIndex + 1}`);
		let img = avatarCard.querySelector('img');
		if (!img) {
			img = document.createElement('img');
			img.style.position = 'absolute';
			img.style.zIndex = '1';
			img.style.width = '100%';
			img.style.height = '100%';
			img.style.objectFit = 'cover';
			img.onerror = function() { this.style.display = 'none'; };
			avatarCard.appendChild(img);
		}
		img.style.display = '';
		img.src = `${IMAGE_BASE_URL}${selectedAvatarSlug}.png`;
		
		closeModal();
	}
	
	// Initialise the app
	renderPlayers();
	updateRemoveDropdown();
	
    </script>
</body>
</html>
